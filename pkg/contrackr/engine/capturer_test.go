package engine

import (
	"net"
	"os"
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestParse(t *testing.T) {
	testCases := []struct {
		desc              string
		packetCapturePath string
		want              []*Connection
		closeErr          error
		wantErr           bool
	}{
		{
			desc: "test inbound TCP SYN is parsed correctly",
			// This was captured via the following command:
			// tcpdump --direction=in -c 1 -s90 -n -X -i wlp3s0 "tcp[tcpflags] == tcp-syn" -w single_syn.pcap
			packetCapturePath: "testdata/single_syn.pcap",
			want: []*Connection{
				{
					Src: &net.TCPAddr{
						IP:   net.ParseIP("192.168.86.158"),
						Port: 41832,
					},
					Dst: &net.TCPAddr{
						IP:   net.ParseIP("192.168.86.191"),
						Port: 1992,
					},
				},
			},
			wantErr: false,
		},
		{
			desc: "test inbound TCP SYN for IPv6 is parsed correctly",
			// this was captured via the following command:
			// tcpdump --direction=in -c 1 -n -X -i any "tcp[tcpflags] == tcp-syn or ip6[13+40]&0x2!=0" -w ipv6.pcap
			packetCapturePath: "testdata/ipv6.pcap",
			want: []*Connection{
				{
					Src: &net.TCPAddr{
						IP:   net.ParseIP("2406:da1c:4bb:9160:5662:60b0:37f6:186e"),
						Port: 37920,
					},
					Dst: &net.TCPAddr{
						IP:   net.ParseIP("2406:da1c:4bb:9160:be8c:85d2:28db:4e29"),
						Port: 22,
					},
				},
			},
			wantErr: false,
		},
		{
			desc: "test inbound TCP SYN with corruption at the end is OK",
			// This was generated by appending $(head -n 1 /dev/urandom) to
			// the end of single_syn.pcap. We ignore corrupted bytes, but should
			// try to parse what we can.
			packetCapturePath: "testdata/single_syn_plus_corrupt.pcap",
			want: []*Connection{
				{
					Src: &net.TCPAddr{
						IP:   net.ParseIP("192.168.86.158"),
						Port: 41832,
					},
					Dst: &net.TCPAddr{
						IP:   net.ParseIP("192.168.86.191"),
						Port: 1992,
					},
				},
			},
			wantErr: false,
		},
		{
			desc:              "test TCP ACK is ignored",
			packetCapturePath: "testdata/single_ack.pcap",
			wantErr:           false,
		},
		{
			desc:              "test non-pcap file is an error",
			packetCapturePath: "testdata/bogus.txt",
			wantErr:           true,
		},
		{
			desc: "test ICMP packet is skipped",
			// This was captured via the following command:
			// tcpdump --direction=in -c 1 -s90 -n -X -i wlp3s0 "icmp and host 192.168.86.158" -w udp.pcap
			packetCapturePath: "testdata/icmp.pcap",
		},
	}
	for _, tC := range testCases {
		t.Run(tC.desc, func(t *testing.T) {
			file, err := os.Open(tC.packetCapturePath)
			if err != nil {
				t.Errorf("os.Open(%s) returned err=%v,want err=%t", tC.packetCapturePath, err, tC.wantErr)
			}
			cptr, err := newCapturerOffline(file)
			if (err != nil) != tC.wantErr {
				t.Errorf("newCapturerOffline() returned err=%v,want err=%t", err, tC.wantErr)
			}

			// Only run if there are no errors (even if we are expecting an error)
			// This is so we can test errors during instantiation.
			if err == nil {
				var got []*Connection
				for i := range cptr.Capture() {
					got = append(got, i)
				}
				if diff := cmp.Diff(tC.want, got); diff != "" {
					t.Errorf("Parse() mismatch (-want +got):\n%s", diff)
				}
			}

			if err := cptr.Close(); err != nil {
				t.Errorf("cptr.Close() = %v, want nil error", err)
			}
		})
	}
}
